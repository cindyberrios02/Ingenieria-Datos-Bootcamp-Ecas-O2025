# Clase 06: Manejo de Excepciones en Python
# Calculadora b√°sica con manejo robusto de errores y funcionalidades avanzadas

import math
import logging
from datetime import datetime
from typing import Union, Tuple, Optional


class CalculadoraAvanzada:
    """
    Calculadora avanzada con manejo completo de excepciones y funcionalidades extras.
    """
    
    def __init__(self):
        """Inicializa la calculadora con configuraci√≥n de logging y historial."""
        self.historial = []
        self.configurar_logging()
        self.operadores_validos = {'+', '-', '*', '/', '^', '%', '//', 'sqrt', 'log'}
    
    def configurar_logging(self):
        """Configura el sistema de logging para registrar operaciones y errores."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('calculadora.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def solicitar_numero(self, mensaje: str) -> float:
        """
        Solicita un n√∫mero al usuario con validaci√≥n robusta.
        
        Args:
            mensaje (str): Mensaje a mostrar al usuario
            
        Returns:
            float: N√∫mero validado del usuario
            
        Raises:
            ValueError: Si la entrada no es un n√∫mero v√°lido
            KeyboardInterrupt: Si el usuario cancela la operaci√≥n
        """
        while True:
            try:
                entrada = input(mensaje).strip()
                
                # Verificar si el usuario quiere cancelar
                if entrada.lower() in ['salir', 'exit', 'quit', 'cancelar']:
                    raise KeyboardInterrupt("Operaci√≥n cancelada por el usuario")
                
                # Validar entrada vac√≠a
                if not entrada:
                    raise ValueError("No puedes dejar esto vac√≠o")
                
                # Intentar convertir a n√∫mero
                numero = float(entrada)
                
                # Validar que no sea infinito o NaN
                if math.isinf(numero):
                    raise ValueError("El n√∫mero no puede ser infinito")
                if math.isnan(numero):
                    raise ValueError("Entrada inv√°lida (NaN)")
                
                self.logger.info(f"N√∫mero v√°lido ingresado: {numero}")
                return numero
                
            except ValueError as e:
                if "could not convert" in str(e):
                    print(f"‚ùå Error: '{entrada}' no es un n√∫mero v√°lido. Intenta de nuevo.")
                else:
                    print(f"‚ùå Error: {e}")
                print("üí° Tip: Puedes escribir 'salir' para cancelar")
                continue
    
    def solicitar_operador(self) -> str:
        """
        Solicita el operador al usuario con validaci√≥n.
        
        Returns:
            str: Operador validado
            
        Raises:
            ValueError: Si el operador no es v√°lido
            KeyboardInterrupt: Si el usuario cancela la operaci√≥n
        """
        print(f"\nüî¢ Operadores disponibles:")
        print(f"   +  : Suma")
        print(f"   -  : Resta")
        print(f"   *  : Multiplicaci√≥n")
        print(f"   /  : Divisi√≥n")
        print(f"   ^  : Potencia")
        print(f"   %  : M√≥dulo (resto)")
        print(f"   // : Divisi√≥n entera")
        print(f"   sqrt: Ra√≠z cuadrada (solo primer n√∫mero)")
        print(f"   log: Logaritmo natural (solo primer n√∫mero)")
        
        while True:
            try:
                operador = input("\nüî∏ Ingresa la operaci√≥n: ").strip()
                
                # Verificar cancelaci√≥n
                if operador.lower() in ['salir', 'exit', 'quit', 'cancelar']:
                    raise KeyboardInterrupt("Operaci√≥n cancelada por el usuario")
                
                # Validar entrada vac√≠a
                if not operador:
                    raise ValueError("Debes ingresar un operador")
                
                # Validar operador
                if operador not in self.operadores_validos:
                    operadores_str = ', '.join(sorted(self.operadores_validos))
                    raise ValueError(f"Operador '{operador}' no v√°lido. Usa: {operadores_str}")
                
                self.logger.info(f"Operador v√°lido seleccionado: {operador}")
                return operador
                
            except ValueError as e:
                print(f"‚ùå Error: {e}")
                print("üí° Tip: Puedes escribir 'salir' para cancelar")
                continue
    
    def realizar_operacion(self, num1: float, num2: float, operador: str) -> float:
        """
        Realiza la operaci√≥n matem√°tica especificada.
        
        Args:
            num1 (float): Primer n√∫mero
            num2 (float): Segundo n√∫mero
            operador (str): Operador matem√°tico
            
        Returns:
            float: Resultado de la operaci√≥n
            
        Raises:
            ZeroDivisionError: Para divisiones por cero
            ValueError: Para operaciones inv√°lidas (ra√≠z negativa, log de negativo)
            OverflowError: Para resultados demasiado grandes
        """
        try:
            if operador == "+":
                resultado = num1 + num2
                
            elif operador == "-":
                resultado = num1 - num2
                
            elif operador == "*":
                resultado = num1 * num2
                
            elif operador == "/":
                if num2 == 0:
                    raise ZeroDivisionError("No se puede dividir por cero")
                resultado = num1 / num2
                
            elif operador == "^":
                # Validar potencias problem√°ticas
                if num1 == 0 and num2 < 0:
                    raise ZeroDivisionError("No se puede elevar 0 a una potencia negativa")
                if num1 < 0 and not num2.is_integer():
                    raise ValueError("No se puede elevar un n√∫mero negativo a una potencia decimal")
                resultado = num1 ** num2
                
            elif operador == "%":
                if num2 == 0:
                    raise ZeroDivisionError("No se puede calcular m√≥dulo con divisor cero")
                resultado = num1 % num2
                
            elif operador == "//":
                if num2 == 0:
                    raise ZeroDivisionError("No se puede hacer divisi√≥n entera por cero")
                resultado = num1 // num2
                
            elif operador == "sqrt":
                if num1 < 0:
                    raise ValueError("No se puede calcular la ra√≠z cuadrada de un n√∫mero negativo")
                resultado = math.sqrt(num1)
                
            elif operador == "log":
                if num1 <= 0:
                    raise ValueError("No se puede calcular logaritmo de un n√∫mero menor o igual a cero")
                resultado = math.log(num1)
            
            # Validar resultado
            if math.isinf(resultado):
                raise OverflowError("El resultado es demasiado grande")
            if math.isnan(resultado):
                raise ValueError("El resultado no es un n√∫mero v√°lido")
            
            self.logger.info(f"Operaci√≥n exitosa: {num1} {operador} {num2} = {resultado}")
            return resultado
            
        except (ZeroDivisionError, ValueError, OverflowError) as e:
            self.logger.error(f"Error en operaci√≥n: {num1} {operador} {num2} - {e}")
            raise
    
    def formatear_resultado(self, num1: float, num2: float, operador: str, resultado: float) -> str:
        """
        Formatea el resultado de manera amigable.
        
        Args:
            num1, num2 (float): N√∫meros de la operaci√≥n
            operador (str): Operador usado
            resultado (float): Resultado de la operaci√≥n
            
        Returns:
            str: Resultado formateado
        """
        if operador in ['sqrt', 'log']:
            if operador == 'sqrt':
                return f"‚àö{num1} = {resultado:.6f}"
            else:  # log
                return f"ln({num1}) = {resultado:.6f}"
        else:
            return f"{num1} {operador} {num2} = {resultado:.6f}"
    
    def agregar_al_historial(self, operacion: str, resultado: float):
        """
        Agrega una operaci√≥n al historial.
        
        Args:
            operacion (str): Descripci√≥n de la operaci√≥n
            resultado (float): Resultado obtenido
        """
        entrada_historial = {
            'timestamp': datetime.now(),
            'operacion': operacion,
            'resultado': resultado
        }
        self.historial.append(entrada_historial)
        
        # Limitar historial a √∫ltimas 50 operaciones
        if len(self.historial) > 50:
            self.historial.pop(0)
    
    def mostrar_historial(self):
        """Muestra el historial de operaciones."""
        if not self.historial:
            print("üìã No hay operaciones en el historial")
            return
        
        print(f"\nüìã HISTORIAL DE OPERACIONES ({len(self.historial)} entradas)")
        print("=" * 60)
        
        for i, entrada in enumerate(self.historial[-10:], 1):  # √öltimas 10
            timestamp = entrada['timestamp'].strftime("%H:%M:%S")
            print(f"{i:2d}. [{timestamp}] {entrada['operacion']} = {entrada['resultado']:.6f}")
    
    def calculadora_basica(self):
        """
        Funci√≥n principal de la calculadora (cumple los requisitos b√°sicos).
        """
        print("üßÆ CALCULADORA B√ÅSICA")
        print("=" * 30)
        print("Realiza una operaci√≥n matem√°tica con manejo de excepciones")
        
        try:
            # Solicitar primer n√∫mero
            num1 = self.solicitar_numero("üî∏ Ingresa el primer n√∫mero: ")
            
            # Solicitar operador
            operador = self.solicitar_operador()
            
            # Para operaciones unarias, no necesitamos segundo n√∫mero
            if operador in ['sqrt', 'log']:
                num2 = 0  # No se usa, pero lo ponemos para consistencia
                print(f"\nüîÑ Calculando {operador}({num1})...")
            else:
                # Solicitar segundo n√∫mero
                num2 = self.solicitar_numero("üî∏ Ingresa el segundo n√∫mero: ")
                print(f"\nüîÑ Calculando {num1} {operador} {num2}...")
            
            # Realizar operaci√≥n
            resultado = self.realizar_operacion(num1, num2, operador)
            
            # Formatear y mostrar resultado
            operacion_str = self.formatear_resultado(num1, num2, operador, resultado)
            print(f"\n‚úÖ RESULTADO:")
            print(f"   {operacion_str}")
            
            # Agregar al historial
            self.agregar_al_historial(operacion_str, resultado)
            
        except ValueError as ve:
            print(f"\n‚ùå Error de valor: {ve}")
            self.logger.error(f"ValueError: {ve}")
            
        except ZeroDivisionError as zde:
            print(f"\n‚ùå Error de divisi√≥n: {zde}")
            self.logger.error(f"ZeroDivisionError: {zde}")
            
        except OverflowError as oe:
            print(f"\n‚ùå Error de overflow: {oe}")
            self.logger.error(f"OverflowError: {oe}")
            
        except KeyboardInterrupt:
            print(f"\n‚èπÔ∏è Operaci√≥n cancelada por el usuario")
            self.logger.info("Operaci√≥n cancelada por el usuario")
            
        except Exception as e:
            print(f"\n‚ùå Error inesperado: {e}")
            self.logger.error(f"Error inesperado: {e}")
            
        finally:
            print("\nüîö Operaci√≥n finalizada.")
    
    def calculadora_con_repeticion(self):
        """
        Calculadora con opci√≥n de repetir (Ejercicio PLUS).
        """
        print("üîÑ CALCULADORA CON REPETICI√ìN")
        print("=" * 35)
        print("Realiza m√∫ltiples operaciones hasta que decidas salir")
        
        operacion_numero = 0
        
        while True:
            try:
                operacion_numero += 1
                print(f"\n{'='*50}")
                print(f"üî¢ OPERACI√ìN #{operacion_numero}")
                print(f"{'='*50}")
                
                # Ejecutar una operaci√≥n
                self.calculadora_basica()
                
                # Preguntar si continuar
                print(f"\nü§î ¬øQu√© quieres hacer ahora?")
                print("1. ‚ûï Realizar otra operaci√≥n")
                print("2. üìã Ver historial")
                print("3. üóëÔ∏è Limpiar historial")
                print("4. üö™ Salir")
                
                while True:
                    try:
                        opcion = input("\nüëâ Selecciona una opci√≥n (1-4): ").strip()
                        
                        if opcion == "1":
                            break  # Continuar con otra operaci√≥n
                        elif opcion == "2":
                            self.mostrar_historial()
                            continue
                        elif opcion == "3":
                            self.historial.clear()
                            print("‚úÖ Historial limpiado")
                            continue
                        elif opcion == "4":
                            print("\nüëã ¬°Gracias por usar la calculadora!")
                            print(f"üìä Total de operaciones realizadas: {operacion_numero}")
                            if self.historial:
                                print("üìã Tu historial se ha guardado en 'calculadora.log'")
                            return
                        else:
                            print("‚ùå Opci√≥n no v√°lida. Selecciona 1, 2, 3 o 4.")
                            continue
                            
                    except KeyboardInterrupt:
                        print("\n\nüëã ¬°Hasta luego!")
                        return
                        
            except KeyboardInterrupt:
                print("\n\nüëã ¬°Hasta luego!")
                return
            except Exception as e:
                print(f"\n‚ùå Error cr√≠tico: {e}")
                self.logger.critical(f"Error cr√≠tico en calculadora_con_repeticion: {e}")
                continue
    
    def modo_evaluacion_expresiones(self):
        """
        Modo avanzado que permite evaluar expresiones matem√°ticas completas.
        """
        print("üß† MODO EVALUACI√ìN DE EXPRESIONES")
        print("=" * 40)
        print("Eval√∫a expresiones matem√°ticas completas")
        print("Ejemplo: 2 + 3 * 4, (5 + 3) / 2, etc.")
        print("‚ö†Ô∏è ADVERTENCIA: Solo usa expresiones matem√°ticas simples")
        
        while True:
            try:
                expresion = input("\nüî∏ Ingresa la expresi√≥n (o 'salir'): ").strip()
                
                if expresion.lower() in ['salir', 'exit', 'quit']:
                    break
                
                if not expresion:
                    print("‚ùå Debes ingresar una expresi√≥n")
                    continue
                
                # Validar caracteres permitidos (solo n√∫meros, operadores y par√©ntesis)
                caracteres_permitidos = set("0123456789+-*/()%. ")
                if not all(c in caracteres_permitidos for c in expresion):
                    raise ValueError("La expresi√≥n contiene caracteres no permitidos")
                
                # Evaluar la expresi√≥n
                resultado = eval(expresion)
                
                print(f"‚úÖ {expresion} = {resultado:.6f}")
                self.agregar_al_historial(expresion, resultado)
                
            except ZeroDivisionError:
                print("‚ùå Error: Divisi√≥n por cero en la expresi√≥n")
            except SyntaxError:
                print("‚ùå Error: Sintaxis inv√°lida en la expresi√≥n")
            except ValueError as e:
                print(f"‚ùå Error: {e}")
            except Exception as e:
                print(f"‚ùå Error al evaluar: {e}")
    
    def mostrar_estadisticas(self):
        """Muestra estad√≠sticas del uso de la calculadora."""
        if not self.historial:
            print("üìä No hay estad√≠sticas disponibles")
            return
        
        print(f"\nüìä ESTAD√çSTICAS DE USO")
        print("=" * 30)
        
        # Contar operadores usados
        operadores_count = {}
        resultados = []
        
        for entrada in self.historial:
            operacion = entrada['operacion']
            resultado = entrada['resultado']
            resultados.append(resultado)
            
            # Extraer operador (simplificado)
            for op in self.operadores_validos:
                if op in operacion:
                    operadores_count[op] = operadores_count.get(op, 0) + 1
                    break
        
        print(f"üìà Total de operaciones: {len(self.historial)}")
        print(f"üìä Promedio de resultados: {sum(resultados)/len(resultados):.2f}")
        print(f"üîù Resultado m√°ximo: {max(resultados):.2f}")
        print(f"üîª Resultado m√≠nimo: {min(resultados):.2f}")
        
        if operadores_count:
            print(f"\nüî¢ Operadores m√°s usados:")
            for op, count in sorted(operadores_count.items(), key=lambda x: x[1], reverse=True):
                print(f"   {op}: {count} veces")


def demo_manejo_excepciones():
    """
    Funci√≥n de demostraci√≥n de diferentes tipos de excepciones.
    """
    print("üéì DEMO: MANEJO DE EXCEPCIONES")
    print("=" * 40)
    print("Demostraci√≥n de diferentes casos de error y su manejo")
    
    calc = CalculadoraAvanzada()
    
    casos_demo = [
        ("Divisi√≥n por cero", 10, 0, "/"),
        ("Entrada no num√©rica", "abc", 5, "+"),
        ("Operador inv√°lido", 5, 3, "&"),
        ("Ra√≠z de negativo", -4, 0, "sqrt"),
        ("Logaritmo de negativo", -2, 0, "log"),
        ("Potencia problem√°tica", -2, 0.5, "^"),
        ("Operaci√≥n v√°lida", 10, 5, "+")
    ]
    
    for descripcion, num1, num2, op in casos_demo:
        print(f"\nüß™ Caso: {descripcion}")
        print(f"   Operaci√≥n: {num1} {op} {num2}")
        
        try:
            if isinstance(num1, str):
                # Simular error de conversi√≥n
                num1 = float(num1)
            
            if op not in calc.operadores_validos:
                raise ValueError(f"Operador '{op}' no v√°lido")
            
            resultado = calc.realizar_operacion(num1, num2, op)
            print(f"   ‚úÖ Resultado: {resultado:.6f}")
            
        except ValueError as e:
            print(f"   ‚ùå ValueError: {e}")
        except ZeroDivisionError as e:
            print(f"   ‚ùå ZeroDivisionError: {e}")
        except Exception as e:
            print(f"   ‚ùå Error: {e}")


def menu_principal():
    """
    Men√∫ principal de la calculadora con todas las opciones.
    """
    calc = CalculadoraAvanzada()
    
    while True:
        print(f"\n" + "="*60)
        print("üßÆ SISTEMA DE CALCULADORA AVANZADA")
        print("üéì Clase 06 - Manejo de Excepciones en Python")
        print("="*60)
        print("Selecciona una opci√≥n:")
        print("1. üî¢ Calculadora b√°sica (requisitos m√≠nimos)")
        print("2. üîÑ Calculadora con repetici√≥n (PLUS)")
        print("3. üß† Evaluador de expresiones (avanzado)")
        print("4. üìã Ver historial de operaciones")
        print("5. üìä Mostrar estad√≠sticas de uso")
        print("6. üóëÔ∏è Limpiar historial")
        print("7. üéì Demo de manejo de excepciones")
        print("8. üíæ Exportar historial a archivo")
        print("0. üö™ Salir")
        print("-" * 60)
        
        try:
            opcion = input("üëâ Ingresa tu opci√≥n (0-8): ").strip()
            
            if opcion == "0":
                print("\nüëã ¬°Gracias por usar la calculadora avanzada!")
                if calc.historial:
                    print("üìã Tu historial se guard√≥ autom√°ticamente")
                break
                
            elif opcion == "1":
                calc.calculadora_basica()
                
            elif opcion == "2":
                calc.calculadora_con_repeticion()
                
            elif opcion == "3":
                calc.modo_evaluacion_expresiones()
                
            elif opcion == "4":
                calc.mostrar_historial()
                
            elif opcion == "5":
                calc.mostrar_estadisticas()
                
            elif opcion == "6":
                if calc.historial:
                    calc.historial.clear()
                    print("‚úÖ Historial limpiado exitosamente")
                else:
                    print("üìã El historial ya est√° vac√≠o")
                    
            elif opcion == "7":
                demo_manejo_excepciones()
                
            elif opcion == "8":
                if calc.historial:
                    try:
                        with open("historial_calculadora.txt", "w", encoding="utf-8") as f:
                            f.write("HISTORIAL DE CALCULADORA\n")
                            f.write("=" * 50 + "\n\n")
                            for entrada in calc.historial:
                                timestamp = entrada['timestamp'].strftime("%Y-%m-%d %H:%M:%S")
                                f.write(f"[{timestamp}] {entrada['operacion']} = {entrada['resultado']}\n")
                        print("‚úÖ Historial exportado a 'historial_calculadora.txt'")
                    except Exception as e:
                        print(f"‚ùå Error al exportar: {e}")
                else:
                    print("üìã No hay historial para exportar")
                    
            else:
                print("‚ùå Opci√≥n no v√°lida. Selecciona un n√∫mero del 0 al 8.")
            
            if opcion != "0":
                input("\n‚è∏Ô∏è Presiona Enter para continuar...")
                
        except KeyboardInterrupt:
            print("\n\nüëã ¬°Hasta luego!")
            break
        except Exception as e:
            print(f"\n‚ùå Error inesperado: {e}")
            input("\n‚è∏Ô∏è Presiona Enter para continuar...")


if __name__ == "__main__":
    print("üéì BOOTCAMP INGENIER√çA DE DATOS - CLASE 06")
    print("üßÆ Manejo de Excepciones con Calculadora Avanzada")
    print("üéØ Try, Except, Else, Finally en acci√≥n")
    
    menu_principal()